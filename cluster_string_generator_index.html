<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cluster Jewel String Generator (poe.re-style)</title>
  <style>
    :root{font-family:Inter,system-ui,Segoe UI,Arial,sans-serif;color:#0b1220}
    body{margin:0;padding:20px;background:#f7fafc}
    .container{max-width:980px;margin:0 auto;background:#fff;border-radius:10px;padding:18px;box-shadow:0 6px 20px rgba(12,15,22,.06)}
    h1{font-size:1.25rem;margin:0 0 12px}
    p.lead{margin:0 0 18px;color:#334155}
    .row{display:flex;gap:12px}
    select,input[type=text]{padding:8px;border:1px solid #e2e8f0;border-radius:6px}
    .panel{background:#f8fafc;padding:12px;border-radius:8px;border:1px solid #eef2f7}
    .list{max-height:300px;overflow:auto;padding:8px;border-radius:8px;background:#fff;border:1px solid #eef2f7}
    label.item{display:flex;align-items:center;gap:8px;padding:4px 6px}
    .controls{display:flex;gap:8px;align-items:center;margin-top:12px}
    button{padding:8px 12px;border-radius:8px;border:0;background:#0ea5a4;color:#fff;cursor:pointer}
    pre.output{background:#0b1220;color:#e6fffa;padding:12px;border-radius:8px;white-space:pre-wrap}
    .muted{color:#6b7280;font-size:0.9rem}
    .right{margin-left:auto}
    .small{font-size:0.9rem;padding:6px 8px}
  </style>
</head>
<body>
  <div class="container">
    <h1>Cluster Jewel String Generator — compressed (poe.re style)</h1>
    <p class="lead">Select a jewel base (Large/Medium/Small/All), choose required and optional notables, then press <strong>Generate</strong>. The generator first tries PoE's public API; if the API cannot be reached (CORS or offline), it falls back to embedded sample data. Tokens are automatically reduced to minimal unique substrings (4+ chars) for safety.</p>

    <div class="row">
      <div style="flex:1">
        <div class="panel">
          <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
            <label for="base">Jewel base:</label>
            <select id="base"><option value="all">All</option><option value="Large">Large</option><option value="Medium">Medium</option><option value="Small">Small</option></select>
            <button id="load" class="small">Load Notables</button>
            <div class="muted right" id="status">status: idle</div>
          </div>

          <div style="display:flex;gap:12px">
            <div style="flex:1">
              <div class="muted">Required notables (AND).</div>
              <div class="list" id="requiredList"></div>
            </div>
            <div style="width:260px">
              <div class="muted">Optional notables (one-of, OR inside parentheses).</div>
              <div class="list" id="optionalList"></div>
            </div>
          </div>

          <div class="controls">
            <button id="generate">Generate</button>
            <button id="clear" class="small">Clear selection</button>
            <div class="right muted">Mode: <strong id="mode">compressed</strong></div>
          </div>
        </div>

        <div style="margin-top:12px" class="panel">
          <div class="muted">Output (single compressed string):</div>
          <pre class="output" id="output">(press Generate)</pre>
          <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
            <button id="copy">Copy to clipboard</button>
            <button id="explain" class="small">Explain tokens</button>
            <div class="muted right">Length: <span id="length">0</span> chars</div>
          </div>
        </div>

      </div>
    </div>

    <p class="muted" style="margin-top:12px">Notes: This page is static — you can host on GitHub Pages. PoE API responses may be blocked by CORS; the script attempts the API and falls back to embedded data. The tokenizer chooses the shortest unique substring of length ≥4 for each notable name; adjust the min length in the code if you need shorter/longer tokens.</p>
  </div>

<script>
// --- Utility: minimal embedded fallback data (sample, not exhaustive).
// If PoE API is reachable it will be replaced by live data. You may expand this list manually.
const EMBEDDED_NOTABLES = [
  {name:'Burning Bright', size:'Large'},
  {name:'Widespread Destruction', size:'Large'},
  {name:'Cremator', size:'Large'},
  {name:'Smoking Remains', size:'Large'},
  {name:'Master of Fire', size:'Large'},
  {name:'Wasting Affliction', size:'Medium'},
  {name:'Circling Oblivion', size:'Medium'},
  {name:'Flow of Life', size:'Medium'},
  {name:'Dark Ideation', size:'Medium'},
  {name:'Student of Decay', size:'Medium'},
  {name:'Fettle', size:'Small'},
  {name:'Born of Chaos', size:'Small'},
  {name:'Sublime Sensation', size:'Small'}
];

let masterNotables = []; // {name,size,token}
const minTokenLen = 4; // minimal substring length (adjustable)

function setStatus(s){document.getElementById('status').textContent = 'status: '+s}

async function loadNotables(){
  setStatus('loading PoE API...');
  // Attempt to fetch PoE item data (may fail due to CORS)
  try{
    const res = await fetch('https://www.pathofexile.com/api/trade/data/items');
    if(!res.ok) throw new Error('api http '+res.status);
    const data = await res.json();
    // find cluster jewel entries
    const clusterEntries = [];
    if(Array.isArray(data.result)){
      // some API variants wrap data differently
      data.result.forEach(group=>{
        if(group && group.label && /cluster/i.test(group.label)){
          // label contains cluster
          group.options && group.options.forEach(opt=>clusterEntries.push(opt.name))
        }
      })
    }
    // fallback if structure different
    if(clusterEntries.length===0){
      // attempt to find 'Cluster Jewel' in other paths
      (function find(obj){
        if(!obj || typeof obj!=='object') return;
        if(obj.label && /cluster/i.test(obj.label) && Array.isArray(obj.options)){
          obj.options.forEach(o=>clusterEntries.push(o.name));
        }
        Object.values(obj).forEach(v=>find(v));
      })(data);
    }

    if(clusterEntries.length>0){
      // clusterEntries contains raw notable names, but this route may return other types too; map to sizes unknown
      masterNotables = clusterEntries.map(n=>({name:n,size:'Unknown'}));
      setStatus('loaded from PoE API ('+masterNotables.length+' names)');
    }else{
      throw new Error('no cluster entries found in API response');
    }
  }catch(err){
    console.warn('PoE API load failed:',err);
    setStatus('PoE API failed; using embedded sample data');
    masterNotables = EMBEDDED_NOTABLES.map(x=>({name:x.name,size:x.size}));
  }

  // compute tokens
  computeTokens();
  renderLists();
}

function computeTokens(){
  // compute minimal unique substring token for each notable name
  // approach: for increasing length from minTokenLen, test all substrings for uniqueness
  const names = masterNotables.map(o=>o.name);
  const tokens = {};

  // helper to get candidate substrings of given length
  function substrings(s,len){
    const out=new Set();
    const clean = s.replace(/[^A-Za-z0-9 ]+/g,'');
    for(let i=0;i+len<=clean.length;i++){ out.add(clean.substring(i,i+len)); }
    return Array.from(out).filter(t=>t.trim().length===len);
  }

  // build lowercased name map
  const lcNames = names.map(n=>n.toLowerCase());

  for(let i=0;i<masterNotables.length;i++) masterNotables[i].token = null;

  for(let len=minTokenLen; len<=Math.max(6, minTokenLen+2); len++){
    // gather candidates for each name
    const candMap = masterNotables.map((o,idx)=>({idx,subs:substrings(o.name,len).map(s=>s.toLowerCase())}));
    // test each candidate if unique among names
    candMap.forEach(({idx,subs})=>{
      if(masterNotables[idx].token) return; // already assigned
      for(const s of subs){
        // ensure s appears in this name and not in any other name
        let occurs=0; for(const other of lcNames){ if(other.indexOf(s)!==-1) occurs++; if(occurs>1) break; }
        if(occurs===1){ masterNotables[idx].token = normalizeToken(s); break; }
      }
    })
  }

  // final fallback: use first continuous alnum chunk if nothing unique
  masterNotables.forEach(o=>{
    if(!o.token){ const m = o.name.match(/[A-Za-z0-9]{4,}/); o.token = m?normalizeToken(m[0].slice(0,6)):normalizeToken(o.name.slice(0,6)); }
  });
}

function normalizeToken(s){ return s.replace(/\s+/g,'').replace(/[^A-Za-z0-9]/g,''); }

function renderLists(){
  const base = document.getElementById('base').value;
  const req = document.getElementById('requiredList'); req.innerHTML='';
  const opt = document.getElementById('optionalList'); opt.innerHTML='';
  const filtered = masterNotables.filter(n=> base==='all' || (n.size && n.size.toLowerCase()===base.toLowerCase()));
  filtered.sort((a,b)=>a.name.localeCompare(b.name));
  filtered.forEach((n,i)=>{
    const idr = 'req_'+i; const ido='opt_'+i;
    const item = document.createElement('div'); item.className='item';
    const ch = document.createElement('input'); ch.type='checkbox'; ch.id=idr; ch.dataset.idx=i; ch.dataset.type='req';
    const lab = document.createElement('label'); lab.htmlFor=idr; lab.textContent = `${n.name}  [${n.token}]`;
    item.appendChild(ch); item.appendChild(lab); req.appendChild(item.cloneNode(true));

    const item2 = document.createElement('div'); item2.className='item';
    const ch2 = document.createElement('input'); ch2.type='checkbox'; ch2.id=ido; ch2.dataset.idx=i; ch2.dataset.type='opt';
    const lab2 = document.createElement('label'); lab2.htmlFor=ido; lab2.textContent = `${n.name}  [${n.token}]`;
    item2.appendChild(ch2); item2.appendChild(lab2); opt.appendChild(item2);
  });
}

function gatherSelections(){
  // Note: checkboxes created are in filtered order; we map by text inside label
  const required = [];
  const optional = [];
  document.querySelectorAll('#requiredList input[type=checkbox]').forEach(ch=>{ if(ch.checked){ required.push(ch.nextSibling.textContent); } });
  document.querySelectorAll('#optionalList input[type=checkbox]').forEach(ch=>{ if(ch.checked){ optional.push(ch.nextSibling.textContent); } });
  // parse tokens from label text like "Burning Bright  [Burni]"
  function parseToken(labelText){ const m=labelText.match(/\[([^\]]+)\]/); if(m) return m[1]; // token
    // fallback: extract first 4+ letters
    const n = labelText.replace(/\s*\[[^\]]*\]/,'').trim(); return normalizeToken(n.split(' ')[0].slice(0,6)); }
  return {
    requiredTokens: required.map(parseToken),
    optionalTokens: optional.map(parseToken)
  }
}

function buildCompressedString(reqTokens,optTokens){
  // compose: tokens separated by space (AND), optional tokens combined in parentheses with |
  const parts = [];
  const uniqReq = Array.from(new Set(reqTokens.filter(Boolean)));
  const uniqOpt = Array.from(new Set(optTokens.filter(Boolean)));
  parts.push(...uniqReq);
  if(uniqOpt.length>0){ parts.push('('+uniqOpt.join('|')+')'); }
  const out = parts.join(' ');
  return out;
}

// --- UI wiring
window.addEventListener('load',()=>{
  document.getElementById('load').addEventListener('click',loadNotables);
  document.getElementById('generate').addEventListener('click',()=>{
    const sel = gatherSelections();
    if(sel.requiredTokens.length===0 && sel.optionalTokens.length===0){ alert('Select at least one notable (required or optional)'); return; }
    const s = buildCompressedString(sel.requiredTokens,sel.optionalTokens);
    document.getElementById('output').textContent = s;
    document.getElementById('length').textContent = s.length;
  });
  document.getElementById('clear').addEventListener('click',()=>{ document.querySelectorAll('input[type=checkbox]').forEach(ch=>ch.checked=false); document.getElementById('output').textContent=''; document.getElementById('length').textContent=0; });
  document.getElementById('copy').addEventListener('click',async ()=>{ const t=document.getElementById('output').textContent; try{ await navigator.clipboard.writeText(t); alert('copied'); }catch(e){ alert('copy failed — select and copy manually'); } });
  document.getElementById('explain').addEventListener('click',()=>{
    const sel = gatherSelections();
    const map = {};
    masterNotables.forEach(n=>map[normalizeToken(n.name.replace(/[^A-Za-z0-9 ]+/g,''))]=n);
    // build explanation
    const explain = [];
    sel.requiredTokens.forEach(t=>{ explain.push(t + ' -> ' + (masterNotables.find(n=>n.token===t)?.name || 'unknown')); });
    sel.optionalTokens.forEach(t=>{ explain.push(t + ' -> ' + (masterNotables.find(n=>n.token===t)?.name || 'unknown')); });
    if(explain.length===0) alert('no selection'); else alert(explain.join('\n'));
  });
});

// auto-load sample on first open
computeTokens(); renderLists();
</script>
</body>
</html>
